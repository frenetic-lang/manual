% !TEX root = frenetic_programmers_guide.tex

\chapter{Learning Switch}

\section{Design}
\label{l2_learning_switch:design}

Layer 2, or L2, switching revolutionized networking in the 1990's.
As LAN traffic grew, hub performance rapidly degraded as collisions became more and more frequent.
L2 switches effectively cut the LAN into logical segments, performing the forwarding between them.
This dramatically reduced the number of collisions, and also cut down on the traffic that individual
NIC's had to filter out.  Just like the evolution from party lines to direct lines in the Plain Old 
Telephone Network, the evolution from Hubs to L2 switches improved security, speed and quality.

Of course, L2 switches were more sophisticated than hubs.  They required a processor, memory, and 
some form of programming.  In order to know which segments to forward traffic, they needed to 
watch the Ethernet MAC addresses of traffic and remember their respective ports.  

We can simulate the L2 switch with Frenetic.  By doing so, as well see in \ref{l2_learning_switch:timeouts},
we can add features to the switch with just a little extra programming effort.

At a high-level, you can think of a Frenetic network application as:

$$ netkat = f( nib, env ) $$

Where $f$ is your application, $nib$ is the Network Information Base -- the information you have dynamically determined in your network through
packets received by \netkat{pkt\_in} -- and
$env$ is other information (fixed configuration files, out-of-band network measurements, or whatever you want).  
The output, $netkat$ is the NetKAT program.

Naturally, designing $nib$ is critical to a good design.  You don't need to see every packet, and you don't need
to record every detail about the packets you see.  In an L2 switch, we are really only interested in three 
pieces of data:

\begin{itemize}
\item The source MAC address
\item The destination MAC address
\item The switch port connected to the host with a particular MAC address
\end{itemize}

Here's the way we want the switch to behave, in pseudocode:

\begin{minted}{python}
if port_for_mac(EthSrc) == None:
  learn(EthSrc, Port)
if port_for_mac(EthDst) != None:
  pkt_out(payload, port)
else
  pkt_out(payload, all_ports_except(port))
\end{minted}

Admittedly this is pretty sketchy, but it covers the interesting cases.  In particular, it covers
Ethernet broadcasts to MAC address ff:ff:ff:ff:ff:ff just by the fact that a source MAC will never
equal ff:ff:ff:ff:ff:ff.  And flooding is exactly what you want to do in that case.

So our NIB must maintain at least a list of MAC-to-port mappings.  
In our Repeater app, our NIB was a single instance variable in the application itself:
\netkat{self.ports}, which held a list of connected ports on the switch.  
Now we'll evolve a little.
In what will become a standard
part of our network apps, we'll model the NIB as a separate object class in Python.  
The following code is in \netkat{code/l2\_learning\_switch/network\_information\_base.py}:

\inputminted{python}{code/l2_learning_switch/network_information_base.py}

That 
encapsulates the state in one place, making it easy to change underlying data structures later.
It also separates the NIB details from the NetKAT details, making it easier to reuse the code
in other applications later.  

\section{A First Pass}

One of the problems with our switch pseudocode design is it doesn't fit our notions of NetKAT very well.
NetKAT programs do not have variables, so they can't remember MAC-to-port mappings on their own.
So it appears that every packet must pass through the controller so we can make decisions.
Processing every single packet through the controller clearly violates the First NetKAT principle, but
we can leave that aside for now.  It'll be instructive to build an easy but inefficient L2 switch first.

We can use elements from our Repeater application.
The following code is in \netkat{code/l2\_learning\_switch/learning1.py}:

\inputminted[linenos]{python}{code/l2_learning_switch/learning1.py}

There are a couple of new details to note:

\begin{itemize}
\item The \netkat{\_\_init\_\_} constructor must call the superclass constructor to properly initialize.
\item Because we are writing in classes, we now distinguish the main loop of this application with 
a check on \netkat{\_\_main\_\_}.  
\item We are using the RYU packet parsing routines discussed in \ref{introduction:packet_in}
\item The \netkat{packet\_in} looks almost exactly like our pseudocode design
\end{itemize}

Starting up Mininet, Frenetic and our application respectively, we try a \netkat{pingall} in Mininet and see
the following on the console:

\begin{minted}{console}
vagrant@frenetic:~/manual/programmers_guide/code/l2_learning_switch$ python learning1.py
Starting the tornado event loop (does not return).
2016-04-14 12:49:17,228 [INFO] Connected to Frenetic - Switches: {1: [4, 2, 1, 3]}
2016-04-14 12:49:17,229 [INFO] Learning: 9a:0f:ec:39:54:f5 attached to ( 1 )
2016-04-14 12:49:17,258 [INFO] Learning: be:3f:5a:90:8a:ac attached to ( 2 )
2016-04-14 12:49:17,303 [INFO] Learning: 3a:a4:6b:e6:24:25 attached to ( 3 )
2016-04-14 12:49:17,343 [INFO] Learning: f2:a7:c0:cb:90:23 attached to ( 4 )
\end{minted}

The switch works perfectly!  But it's a huge violation of Principle 1.  

\section{A More Efficient Switch}

Once we've learned a MAC-to-port
mapping, we shouldn't have to go to the controller for packets destined for that MAC.  The switch
should handle it by itself.

This is actually pretty straightforward.  If we know that MAC 11:11:11:11:11:11 is on port 2, we
can handle it with the following NetKAT program:

\begin{minted}{python}
Filter(EthDstEq("11:11:11:11:11:11")) >> SetPort(2)
\end{minted}

And we just need one of these rules for each MAC we've learned.  But all of these rules are non-overlapping
because they involve different values for \netkat{EthDst}.  So we just Union them all together and that's
our entire NetKAT program.

So let's write some methods for calculating the policies
We'll add this code to learning1 (listed in \netkat{code/l2\_learning\_switch/learning2.py}:

\inputminted[firstline=24,lastline=32]{python}{code/l2_learning_switch/learning2.py}

When shall we install these rules?   We could install them on every incoming packet, but that's a little
overkill. We really only need to recalculate them when we see a newly learned MAC and port.  So we add them
to that conditional:

\inputminted[firstline=42,lastline=45]{python}{code/l2_learning_switch/learning2.py}

Now run it and try a pingall from Mininet:

\begin{minted}{console}
vagrant@frenetic:~/manual/programmers_guide/code/l2_learning_switch$ python learning1.py
Starting the tornado event loop (does not return).
2016-04-14 13:33:22,965 [INFO] Connected to Frenetic - Switches: {1: [2, 4, 1, 3]}
2016-04-14 13:33:26,447 [INFO] Learning: 86:d8:df:f0:95:75 attached to ( 1 )
2016-04-14 13:33:26,453 [INFO] Learning: 4a:1c:9e:9b:50:7c attached to ( 2 )
... STOP
\end{minted}

Uh oh.  Why did we only learn the first two ports?   Let's look at the Frenetic console for a clue:

\begin{minted}{console}
[DEBUG] Installing policy
drop |
(filter ethDst = 4a:1c:9e:9b:50:7c; port := 2 |
 filter ethDst = 86:d8:df:f0:95:75; port := 1)
[DEBUG] Setting up flow table
+----------------------------------------+
| 1 | Pattern                | Action    |
|----------------------------------------|
| EthDst = 4a:1c:9e:9b:50:7c | Output(2) |
|----------------------------------------|
| EthDst = 86:d8:df:f0:95:75 | Output(1) |
|----------------------------------------|
|                            |           |
+----------------------------------------+
\end{minted}

Can you see the problem?  There's no longer a rule to send packets to the controller.  If packets
are destined for the first two MAC addresses, that's not a problem, but if they're not, it is definitely 
a problem.

One thing that definitely \emph{won't} work is to add the following rule with a Union:

\begin{minted}{python}
id >> SendToController("learning_app")
\end{minted}

The \netkat{id} filter matches all packets, and therefore overlaps every other rule.  Even if we place this
rule as the last rule in a set of Unions, \emph{that does not guarantee it'll be fired last.}  Frenetic 
does not guarantee the OpenFlow rules will follow the order of the NetKAT rules.     

There are a few ways to solve this problem, but we'll try an easy one first.  
In Chapter 2, we mentioned briefly that for every \netkat{FieldEq} NetKAT predicate, there is a corresponding
\netkat{FieldNotEq} predicate.  We can use that in our policy, as we see in \netkat{learning3.py}:

\inputminted[firstline=31,lastline=37]{python}{code/l2_learning_switch/learning3.py}

TODO: The first ping from h1 to h2 fails the first time, even though all the subsequent ones work, and 
the seond pingall works 100 percent.  

\section{Timeouts and Moves}
\label{l2_learning_switch:timeouts}

Our learning switch works fine if MAC to port assignments never change.  But a network is usually
more fluid than that:

\begin{itemize}
\item People unplug a host from one port and plug it into another.  In our application, packets will
continue to go to the old port.
\item People replace one host and MAC with another host and MAC in the same port.  In our application, the
old MAC will continue to take up rule space on the switch.  
\end{itemize}

TODO: These can handled with portup and portdown hooks.  But it's unclear that they fully solve the problem. 
And it's not clear they solve malicious users from forging an existing MAC and hijacking traffic.  
